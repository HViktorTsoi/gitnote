# Interactive slam说明文档
## 安装
按照[github](https://github.com/SMRT-AIST/interactive_slam)上的文档进行安装。

注意这个包对Ubuntu18下的melodic支持较好，对Ubuntu16和Kinetic支持不好，需要额外装LLVM。

这个算法支持三种模式
1. 与hdl_graph_slam结合使用。直接使用hdl_graph_slam保存的中间地图和位姿结果。这个模式用的不多。
2. 用自定义的位姿源。即用任意其他的SLAM算法产生的位姿+对应点云得到初始地图，并对地图进行编辑。这个模式用的最多。
3. 地图合并。可以将多个通过interactive_slam编辑之后的地图合并为一个大地图。

## 说明
这里主要对模式2，即用其他SLAM算法产生的位姿获取初始地图，并对地图进行编辑。

### 1. 在建图过程中保存点云和对应的Odometry
1. 首先按照文档中的命令，编译odometry_saver包:
 https://github.com/SMRT-AIST/interactive_slam/wiki/Example2#installation
2. 然后运行odometry_saver节点，准备保存位姿和点云。这里需要对保存路径、点云/位姿topic，起始点frame_id，载体的frame_id进行配置。具体参考文档就可。
3. 运行任意可以提供Odometry的SLAM算法。这里需要注意的最关键一点是，**SLAM算法的点云和里程计必须是同时发布的，并且数量必须一致。(否则odometry_saver会保存数量不一致的点云和位姿帧数，从而导致后续的地图编辑器无法正确导入)。经过实际测试，一个可行的同时发布方法，就是在SLAM算法的同一个node的同一个function中，先后发布点云和位姿的msg，并且两个msg使用相同的时间戳。**
4. 运行完SLAM算法之后，观察到保存路径下有多帧对应的.pcd和.odom文件，说明保存成功。


### 2. 初始位姿图生成
这一步是利用SLAM给的位姿，构建初始位姿图，具体流程按照文档来就可以
https://github.com/SMRT-AIST/interactive_slam/wiki/Example2#generate-graph-data-from-odometry

需要注意的是，这里需要对**点云下采样的粒度**和**关键帧间隔**进行设置，后续的地图修正都是在这个点云和关键帧密度下进行的，并且最后保存的完整地图包含的点云帧数=设置的关键帧密度下的关键帧数，需要做好数据量和运行时间的平衡。


### 3. 地图修正
这一部分文档中同样有详细的说明。

https://github.com/SMRT-AIST/interactive_slam/wiki/Example3

这里对几个关键流程进行说明：

1. 导入地图后，如果场景中存在回环，首先手动添加回环约束。添加之后会弹出来一个窗口，对回环首末两端的点云进行半自动的配准，这里需要仔细检查两帧点云是否精确的配准了，这里对整个地图的精度有比较关键的影响。
2. 使用平面约束对地图中的扭曲进行修正。按照文档中的方法，想要添加平面约束，首先要选择这个平面附近的一个种子点，这里最好把点的渲染size调大，确定选择的点属于待约束的平面。在实际修图过程中，一般添加的平面约束有：
   1. 地面约束，这是一元约束，限制平面与xOy平面重合
   2. 平面平行约束，这是二元约束，一般用来限制多个天花板/墙面平行
   3. 平面垂直约束，二元约束，一般用来限制多个墙面垂直
3. 每次添加约束后，需要使用Edge refinement对位姿图进行优化， 才能达到修正地图的效果

### 4. 地图保存/导出
1. 保存的地图格式与2中生成的初始地图格式完全一致，所以在保存之后还可以打开继续编辑
2. 导出地图为原始未下采样点云经过修正后位姿叠加后得到的点云地图。