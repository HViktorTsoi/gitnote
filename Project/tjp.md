# Note

## 车顶行李架 做成车窗+紧固手拧螺丝(但是需要车辆宽度)

## yesense 时间同步
******* ysense出现姿态角过调的现象, 是不是由于没有时间同步导致的?
1. 从FSYNC给一个1Hz的脉冲
2. imu会被这个脉冲触发, 采集数据, 采完之后, 会通过int发一个高电平, 通知已经采集完成
3. imu输出的同步时间戳是相对于上一次的1Hz脉冲上升沿的相对时间
4. 在驱动里发现, 当没有用pps触发的时候, 采样时间和输出时间在数据帧中都是没有的


## 惯导标定要点
1. 当双天线构成的直线与惯导x轴有相对角度时, 标定前需要写入这个角度
2. 当惯导x轴与车体x轴有相对角度时,标定时需要写入这个角度, 但是一般安装时要求惯导x与载体x重叠
3. 标定和验证时都要保存数据, 便于给技术验证标定是否准确

## 惯导激光标定
1. 用liosam建出来的图是准的, 但是惯导+imu消除畸变的点云叠加出来的图就差很多, 最终效果感觉是imu过度矫正了点云的畸变
2. 用ins和imu消除畸变的点云做ndt mapping, 50米有效范围, map的divergence都比用原始点云好
3. 是不是时间同步的问题, 用队列将惯导和雷达的时间戳错开, 手动添加latch, 然后将雷达转换到utm和惯导坐标系
4. 对3进行实验之后,发现确实, 将lidar帧的时间戳手动向前调0.06s之后, 再用去除运动畸变的点云来叠加地图, 效果好了很多
5. 经过位姿插值和未经过位姿插值的确实有很大的误差, 经过imu测量, 车辆最大角速度0.45rad/s, ins频率80Hz, 那么如果未经过位姿插值, 如果LiDAR恰好在两个INS数据中间, 直接使用最近的一帧插值, 则LiDAR位姿和实际位姿差了1/80 * 0.5 * 0.45, 约为0.16度, 如果是50米距离, 那么xOy的偏移大概就要50 * sin(0.16) = 0.14米, 在100米的偏移就为0.3米左右, 这个差距实际上是相当大了
6. 运动畸变
7. 时间同步
8. 外参
9. 惯导精度
10. 惯导频率
11. 位姿插值
12. 当用消除运动畸变和时间差的点云-里程计重新优化外参时, 得到的外参反而不准确了, 地图上又出现了重影, 这个问题需要解决, 可能是修正了外参之后, 时间差系数也应该跟着改变, 原来的时间差系数是不准确的, 后来发现, 优化式filter点云的距离有影响, 一般保留50米可以得到最优结果
13. loss函数的设计有一些问题, 当地图明显不准确时, loss的值却很小, 这可能是在车辆运动时, 由于雷达的稀疏性,相邻两帧点云
14. 惯导标定需要有一定的速度, 并且8字轨迹不能太重复, 轨迹的半径尽量要大于外参的杆臂长度
15. 跑LIOSAM的时候, 发现IMU和雷达也需要较为精确
16. Robosense的时间同步, 要求time mode从255改成2
17. ins570d 05模式是“非debug"模式，这时输出的信息才全都是有用的信息
18. ins570d的定位坐标转换: 
                       惯导->主天线位置矢量               惯导-后轮中心位置矢量
    主天线GNSS转笛卡尔 ---------------------> 惯导坐标系 -------------------------> 后轮中心坐标系

## hdl localization
1. IMU LiDAR 外参标定

## LIO localization
跑Dan Hai的定位算法
1. 方案1: 
   1. 忽略odom to map的估计
   2. 直接把global initialization作为map optimization的起始odometry
   3. 在每次全局定位之后, 把全局transform作为gps factor, 加入因子图进行优化
2. 方案2:
   1. 维护odom to map;
   2. 每次全局定位只有, 把全局transform作为gps factor, 加入因子图进行优化. (验证是不是要把全局定位转换到odometry系再加到因子图中)

# multilidar localization
1. 维护一个单独的imu preintegration不变
2. 更改msg形式，使其存储每个LiDAR的id
3. 对于每个lidar，单独使用image projection和feature extraction
4. 在image projection中，维护LiDAR数量的imuQ，将imu对齐到不同的LiDAR系下
5. 在graphLocalization中，用外参将每个LiDAR的特征经过时间同步之后融合在一起，然后进行scan2map的里程计估算以及全局定位
6. 对于2和5，第二种方式是在image projection收到每个LiDAR之后，直接全都转换到base lidar的坐标系下，这样imu deskew等维持原样就可以
7. 考虑像DC一样，因子图中每个节点的状态除了位姿之外，还要有lidar的外参

DC Loam Livox中的方案：
1. 在提特征的部分维护一个subscriber列表， 订阅多路原始点云；
2. 对每一路原始点云提取特征（局部坐标系的），标记相应的lidar id之后发布出去；
3. 在mapping过程中，接受每个lidar单独的特征（局部坐标系的），用事先标定好的外参将特征统一到主lidar系下，再进行后续的过程
4. DCloamlivox维护一个42状态的EKF，分别是3轴R, 3轴T, 3轴w, 3轴v， 和5个LiDAR的6dof外参，在slam过程中同时估计这些量


## 开发日志
1. lio localization中, 用滑动窗口win来保存待全局匹配的关键帧, 并且没有保存关键帧id, 如果在全局定位之后直接用win的size来作为因子图节点的ID, 那么这个ID就会是错误的, 在超过滑动窗口大小之后, ID就一直是那个窗口最大长度了
2. 在全局定位之后, 求odom测量值时, 旧的odom2map的tf不一定与关键帧是对应的,这里需要再确定一下
3. 尝试了只使用初始的map to odom(后续不更新), 这和将odom的第一帧设置为map中的绝对位姿是一致的, 结果发现,轨迹确实不会有跳变了, 但是变成低频的凸起了, 这可能说明全局定位的观测量就是不准的
4. reply速度对性能也有影响, 实验发现mapping的速度总会落后odometry几帧 **这是因为我开发的时候关闭了keypose的滑动窗口,现在每次回环检测都要遍历所有的滑动窗口, 待修复**
5. 飞了的情况应该是mapping测量得到的相对距离比imu预积分得到的距离大了, 导致优化出来的ba比实际的大很多, 在后续的积分上,用一个特别大的ba去积分, 当然位姿就飞了
6. 优化之后odometry还是很平滑的， 我们看到的跳变是map to odom 造成的
7. 思考， 为什么用lio relocalization的原始形式， 得到的轨迹不是平滑的？
   1. 如果优化odom to map， 则这个硬性的定时优化当然会影响平滑性
   2. 如果只优化odom， 为什么会轨迹会慢慢远离map？ 第一个因子是0， 在计算的时候转换到map， 与第一个因子是odom2map的区别是什么？？？
8. 我们需要全局轨迹优化吗？ 全局匹配的效果很好， lio的累计误差也不大，是不是不需要优化太久之前的轨迹？？？
9. 一个重要的问题， odometry factor都是用自己构建的local得到的， 而全局定位是根据全局匹配得到的，这样就有个严重的问题：
   1.  当里程计和地图偏差不大的时候， 建出来的地图很平滑
   2.  当里程计和地图偏差很大时， 由于里程计因子的数量很多（且方差很小），地图定位因子的数量很少（且方差很大），最后全局定位无法将里程计拉回来，表现为全局定位时震荡很大，两次定位期间轨迹很平滑但是与地图偏差较大

10. 尝试用map to odom更新起始点坐标（这个只有在odom与轨迹误差是线性的时候好用，即odom累计误差很小的时候）
11. 最后发现确实是线程同步的bug， 访问全局配准关键帧的odom是在全局配准之后，整整和对应关键帧差了1秒（就这样还跑了个八九不离十）；然后发现，全局配准的时刻与当前帧越近，配准的平滑性越好
12. 尝试同时优化imu LiDAR的外参？
13. TODO: 仅保留小的滑动窗口
14. 取消点云运动畸变消除之后， local map的累计误差明显减小了， 此时里程计和地图更一致，这说明IMU和雷达的外参对建图性能影响还是不小的
15. 在之前的实现中， LIOSAM内置一个imu预积分更新的flag，当发生回环或者加入gps时，imu预计分是不更新的，这样可以防止地图更正的跳变（实际上base没有发生这样的运动）导致imu更新出错误的，非常大的ba和bg。
16. 之前在全局定位之后的时候没有更新内存中的关键帧位姿、、、、、、 只有isam里保存了，因此mapping的时候用的还是老的位姿；用的局部地图也是老的位姿，这里非常关键！！！！！！！ **局部地图一定要实时更新，这样才能保证里程计偏的不多**
17. TODO 解决初始化过程中IMU不稳定造成的问题
18. LIOSAM中，odometry-incremental是累计里程计； IMU要使用初始值为0的里程计来初始化，否则会造成初始ba bg优化值的不稳定，会有非常大的跳变
19. 局部地图和全局地图不一致，目前来看这是对的，因为这是因子图修正之后，后端认为局部地图应该有的空间结构，所以可以看出来此时的定位是准确的
20. 将旧的pose全部marginlize之后，结果确实更平滑了，原来跳变的部分变为较为平滑的过渡
21. marginalization必须遵循一定的顺序
22. 添加prior之后再进行marginalization，有可能出现本来是父节点的变量变为子节点，此时如果还是按照原始顺序来margin， 可能把父节点当做叶节点给margin掉了（这个父节点的所有叶子节点会被删除，但是父节点保留（这里待确认）），后边如果再margin原来的那个父节点，就会出现segmentation fault（因为已经被margin掉了）
23. 第二种情况是，添加的先验变量与普通变量连接到同一个父节点上了， isam的marginlize对于这样的情况处理的不正常
24. 经过profile发现，最占用时间的是全局定位和scan2mapoptimization，后端优化的部分只占特别小的一部分，其中marginalization更小
25. 对于杭研院数据集，在interactive slam建图之前，需要关闭liosam的回环检测，并将所有的地面都设置为ground，最后定位没有太大的偏差
26. 是超时的影响？？？？？？？？是超时的影响！！！！！！！！！！！！！！！！！！！！！！！
27. **在isam中，如果后加入的多元因子P（图中已经有一个与P有关的变量了）与当前最新因子的ID（加入时间）差距太远（实际测试表明是相差>=3），贝叶斯树会将P对应的节点转换为一个没有子树的独立的叶子节点，这时如果将P这个独立的叶子节点margin掉会出现严重的bug，即isam自带的marginalization无法删除这个叶子节点，最后这颗树就会出现孤立节点，在update时就会出现out_of_range或者invalid argument错误。**
28. 解决办法：
    1.  将ID相差>=3的全局定位约束直接扔掉，这种情况仅发生在全局定位消耗了过长的时间，因此是偶然发生的，不会严重影响全局定位性能。除非平台性能差，每次全局定位消耗的时间都超过了3个新关键帧的产生时间，这种情况下全局定位约束就会经常丢失
    2.  利用全局定位关键帧-当前最新关键帧的相对里程计，将全局定位转换到当前关键帧对应的坐标系下，这样可以保证约束的时序，但是定位对应帧到当前帧的累计误差会混淆到全局定位信息里，这会不会影响全局定位性能还需要进一步测试
    3.  修改gtsam的某个阈值，使得重构bayes树的间隔增大，这样即使全局定位慢导致定位约束因子滞后，也不会使得贝叶斯树重构成有bug的形式

29. hdl_localization的一系列包会对正常的package查找openmp有影响
30. TODO map localization丢失之后增大odometry滑动窗口大小
31. ICP fitness降不下去的一个重要原因： 距离lidar远处的点在地图内找不到匹配点， 在这种情况下，即使近处的点和地图匹配的非常完美，整体的fitness也会居高不下（因为远处点距离也大，对fitness贡献更大）。解决办法： 要不然就是把lidar超过地图边界的那些点去除掉；要不然就要保证地图范围足够广g


# 旋转固态雷达 + GPS/RTK平均确定位置 + imu确定姿态(imu可能需要地磁对齐)

# ins570d, 在天津港采集的数据IMU完全不可用, 但是在hyy配置的可用, 而且数值抖动非常小, 说明imu质量比较高
ins570d在天津港采集的数据, plot出来之后, 加速度角速度离散情况非常严重, 说明数据解析有一些问题; 而在hyy采集的加速度连续性非常好, 但是高速运动时位姿有问题, 不知道是不是时间不同步导致的

# 轮速计
KAIST提供的是双轮轮速计, 看论文LiDAR Configuration Comparison for Urban Mapping System, 应该是用的后轮轮速计

# 同步之后, 惯导->雷达的时间差为-0.16, 这个误差可能是由于关闭pps的时候不小心触发了上升沿, 导致雷达内计时器被提前清零, 然后又一直没有新的pps和gprmc来修正lidar, 导致雷达产生了钟飘
这个问题需要持续subscribelidar的topic, 把时间戳记录下来
尝试使用gpgga的时间

# 分析LiDAR的时间信息
1. 要从rslidar的difop packet中查看, 这个需要在config中将publish difop packet的选项打开
2. 要下载rslidar的msg包, 并且将rslidarPacket中的builin*****的time换成标准的time字段, 然后编译, 用这个msg才可以解析difop packet
3. packet中的data字段原封不动的保存了lidar中的设备信息寄存器的值, 这个看文档就可以解析

# RS232无法一分二, 需要在时间同步模块上再加一个RS232分流模块
思路: 
1. 232的信号进来, 全部转成TTL
2. 同步模块的入口RX, 用 两个非门 做信号分流, 入口信号RX接出口信号的TX给上位机差分, 入口信号RX经过两次非之后得到的分流信号给后续的时间同步处理模块
3. 同步模块的入口TX与出口信号的RX直接链接, 用于接受上位机差分的结果
4. 地线的问题???
5. RS232需要转TTL才能实现上述逻辑, 所以要不要考虑分线给上位机的信号直接使用UART通信, 然后给时间同步模块的当然也是直接用TTL?

# 为了方便调试, 最好给串口标记别名, 参考此链接
https://blog.csdn.net/beiguodexuecsdn/article/details/103099456

# 同步问题
1. 同步之后建图的误差是耦合的, 包括惯导位姿的误差, 时间同步的误差, 惯导-雷达标定的误差, 点云运动畸变的误差, 
2. 你们这边在不考虑后端优化的情况下能做到什么精度
关键的细节性问题
1. 我们的同步硬件架构, GPRMC大概在PPS之后的70ms之后发送
2. 同步之后Robosense GPRMC lock 频繁跳变
3. 同步之后惯导时间戳和雷达有一个固定的偏移, 0.16s
4. 同步之后的从建图观察到的结果发现 可能还是存在随机的同步误差
5. 实际任务里, 惯导雷达的外参大概多久重新标一次

# 雷达同步问题总结
1. PPS上升沿只要超过一定ms数量(我们用的200ms)即可
2. GPRMC和GPGGGA可以一起发, 但是注意9600的波特率, 串口是串行发的, 9600需要一定的时间;在导远惯导的控制台可以调整这个
3. 对于robosense雷达. 需要最新的(2021年之后)的固件, 并且Time Mode设置成2(默认是255)
4. 对于robosense的新固件, 点云帧的时间戳是最后一个包的时间戳, 而不是起点的时间戳; 
5. 第四点对于其他的雷达会有不同的表现, 这个一定要注意转换, 否则在消除运动畸变的时候会有严重问题
6. 验证的过程中, 运动畸变与外参标定的性能可能会有耦合, 这个需要注意, 最好能放在一起优化(但是会影响时间效率)
7. 有些急转弯的地方不准， 可能是时间有偏差， 考虑在这些地方优化时间差（仅优化时间差，不考虑位姿变化）
8. livox同步：
   1. 首先用2.0的converter， 直接接TTL的pps，白色悬空
   2. livox sdk是通过读取pc上某个串口来获取nmea的，由于pc同时还要用这个串口的nmea来给惯导差分， 所以：
   3. 用socat创建两个虚拟串口， 一个是/dev/sync_forward, 一个是/dev/sync_livox（这两个串口就是转发逻辑，往一个里写，另一个就会读取到相同的数据）
   4. 差分程序在接受nmea之后， 除了用于差分，还往/dev/sync_forward写入； 这时/dev/sync_livox就会接收到相同的报文
   5. /dev/sync_forward和/dev/sync_livox波特率需要设置成相同的， 同时在livox ros driver中，修改 livox_lidar_config.json 的timesync_config， 更改enable_timesync为true，device_name为/dev/sync_livox， 
9. ***在天津港的helios采集的数据，时间同步其实还存在一个问题： 这个LiDAR固件版本是新的， 是以末点为帧时间戳的， 但是建图的时候仍然是以首点为时间戳
10. https://github.com/nkliuhui/sync_gps_lidar_imu_cam 是在上位机驱动处理的相机时间戳, 把每次imu的触发相机的时间publish出来, 相机的driver将这个时间存在队列里, 当图像到达之后, 用队首的时间戳assign给当前帧图像
11. Pointgrey 原生的ros驱动, 是直接用系统当前时间覆盖了相机给出的嵌入式时间https://github.com/ros-drivers/pointgrey_camera_driver/blob/3afc3491c87b195810d0b3720d1613b5f03205c8/pointgrey_camera_driver/src/nodelet.cpp#L495
12. ins和livox同步时, 会观测到位置/时间出现跳变, 在lidar时间戳里没有观测到跳变, 但是在ins时间戳里会观测到跳变
13. ***** 雷达和相机同步, 需要把相邻两帧里和图像对应点拿出来, 而不是使用当前帧对应的点(比如图像是在每次雷达转到前方时拍摄的, 并且雷达每次转到前方之后会发布数据帧, 那么相机图像对应的点应该是上一帧的后半部分+当前帧的前半部分, 而不是当前帧的所有点)


# NDT mapping
1. 完全没用队列来做, ndt花费时间较长时, 用的是旧的点云, 但是确使用最新的位姿来作为initial guess, 这肯定会出问题, 
2. ndt omp是使用两帧gnss之间的相对odom, 加上上一次ndt之后的点云->地图位姿来作为initial guess的, 而不是直接使用gnss pose, 这样的话其实ndt map和gnss没有直接关系(当然准确的情况下ndt odom和gnss pose应该是一致的)


# LiDAR-惯导建图
1. 用LIO-SAM建图, gps odom的第一帧不需要是0, 目前看gtsam会自动把所有的节点align到第一帧gps的坐标系下
2. LIO-SAM在添加gps因子时, 需要poseCovariance在xy方向达到一定程度后才会添加, 即里程计估计的不确定性到达一定程度后, 才会采用gps修正, 实际建图时要考虑调整这个阈值, 看更信任谁的观测量
